#!/usr/bin/env python3 """ Test runner for Decomposer Service Runs test cases and analyzes results """ import json import requests import time import os from datetime import datetime from typing import Dict, List, Any class DecomposerTester: def __init__(self, service_url: str = "http://localhost:8006"): self.service_url = service_url self.results = [] self.test_config = {} def load_test_cases(self, test_file: str = "decomposer_test_cases.json"): """Load test cases from JSON file""" try: with open(test_file, 'r', encoding='utf-8') as f: data = json.load(f) self.test_cases = data['test_cases'] self.test_config = data['test_config'] self.metadata = data['metadata'] print(f"Loaded {len(self.test_cases)} test cases") return True except Exception as e: print(f"Error loading test cases: {e}") return False def check_service_health(self) -> bool: """Check if Decomposer service is healthy""" try: response = requests.get(f"{self.service_url}/health", timeout=5) if response.status_code == 200: data = response.json() print(f"Service status: {data.get('status', 'unknown')}") return data.get('status') == 'healthy' except: pass print("ERROR: Decomposer service is not healthy") return False def run_single_test(self, test_case: Dict) -> Dict: """Run a single test case""" test_id = test_case['id'] claim = test_case['claim'] print(f"\nTesting {test_id}: {claim[:50]}...") try: # Prepare request payload = { "claim": claim, "language": "vietnamese", "max_sub_claims": test_case.get('expected_sub_claims', 3) } # Send request start_time = time.time() response = requests.post( f"{self.service_url}/decompose", json=payload, timeout=self.test_config.get('timeout_seconds', 60) ) processing_time = time.time() - start_time if response.status_code == 200: result = response.json() # Analyze result analysis = self.analyze_result(test_case, result, processing_time) print(f" Status: {'PASS' if analysis['passed'] else 'FAIL'}") print(f" Sub-claims: {len(result.get('sub_claims', []))} (expected: {test_case['expected_sub_claims']})") print(f" Entities: {len(result.get('entities', []))} (expected: {len(test_case['expected_entities'])})") print(f" Processing time: {processing_time:.2f}s") return analysis else: error_msg = f"HTTP {response.status_code}: {response.text}" print(f" ERROR: {error_msg}") return { "test_id": test_id, "claim": claim, "passed": False, "error": error_msg, "processing_time": processing_time } except Exception as e: print(f" ERROR: {e}") return { "test_id": test_id, "claim": claim, "passed": False, "error": str(e), "processing_time": 0 } def analyze_result(self, test_case: Dict, result: Dict, processing_time: float) -> Dict: """Analyze test result against expectations""" test_id = test_case['id'] # Check basic success if not result.get('success', False): return { "test_id": test_id, "claim": test_case['claim'], "passed": False, "error": "Service returned success=False", "processing_time": processing_time } # Analyze sub-claims actual_sub_claims = len(result.get('sub_claims', [])) expected_sub_claims = test_case['expected_sub_claims'] sub_claims_match = abs(actual_sub_claims - expected_sub_claims) <= 1 # Allow 1 difference # Analyze entities actual_entities = result.get('entities', []) expected_entities = test_case['expected_entities'] # Calculate entity overlap entity_overlap = len(set(actual_entities) & set(expected_entities)) entity_coverage = entity_overlap / len(expected_entities) if expected_entities else 0 # Analyze complexity score actual_complexity = result.get('complexity_score', 0) expected_low = test_case['complexity_score_low'] expected_high = test_case['complexity_score_high'] complexity_match = expected_low <= actual_complexity <= expected_high # Overall pass criteria passed = ( sub_claims_match and entity_coverage >= 0.5 and # At least 50% entity coverage complexity_match and processing_time <= self.test_config.get('timeout_seconds', 60) ) return { "test_id": test_id, "claim": test_case['claim'], "passed": passed, "sub_claims": { "actual": actual_sub_claims, "expected": expected_sub_claims, "match": sub_claims_match }, "entities": { "actual": actual_entities, "expected": expected_entities, "overlap": entity_overlap, "coverage": entity_coverage }, "complexity": { "actual": actual_complexity, "expected_low": expected_low, "expected_high": expected_high, "match": complexity_match }, "processing_time": processing_time, "service_result": result } def run_all_tests(self) -> List[Dict]: """Run all test cases""" print(f"Starting Decomposer Service tests...") print(f"Service URL: {self.service_url}") print(f"Total test cases: {len(self.test_cases)}") # Check service health if not self.check_service_health(): return [] # Run tests results = [] passed_count = 0 for test_case in self.test_cases: result = self.run_single_test(test_case) results.append(result) if result['passed']: passed_count += 1 # Calculate summary total_tests = len(results) pass_rate = (passed_count / total_tests) * 100 if total_tests > 0 else 0 summary = { "total_tests": total_tests, "passed": passed_count, "failed": total_tests - passed_count, "pass_rate": pass_rate, "timestamp": datetime.now().isoformat(), "service_url": self.service_url } return results, summary def generate_report(self, results: List[Dict], summary: Dict) -> str: """Generate detailed test report""" report = [] report.append("=" * 80) report.append("DECOMPOSER SERVICE TEST REPORT") report.append("=" * 80) report.append(f"Generated: {summary['timestamp']}") report.append(f"Service URL: {summary['service_url']}") report.append("") # Summary report.append("SUMMARY") report.append("-" * 40) report.append(f"Total Tests: {summary['total_tests']}") report.append(f"Passed: {summary['passed']}") report.append(f"Failed: {summary['failed']}") report.append(f"Pass Rate: {summary['pass_rate']:.1f}%") report.append("") # Failed tests failed_tests = [r for r in results if not r['passed']] if failed_tests: report.append("FAILED TESTS") report.append("-" * 40) for test in failed_tests: report.append(f"ID: {test['test_id']}") report.append(f"Claim: {test['claim']}") if 'error' in test: report.append(f"Error: {test['error']}") else: report.append(f"Sub-claims: {test['sub_claims']['actual']} (expected: {test['sub_claims']['expected']})") report.append(f"Entity coverage: {test['entities']['coverage']:.1%}") report.append(f"Complexity match: {test['complexity']['match']}") report.append("") # Performance analysis processing_times = [r['processing_time'] for r in results if 'processing_time' in r] if processing_times: avg_time = sum(processing_times) / len(processing_times) max_time = max(processing_times) min_time = min(processing_times) report.append("PERFORMANCE ANALYSIS") report.append("-" * 40) report.append(f"Average processing time: {avg_time:.2f}s") report.append(f"Max processing time: {max_time:.2f}s") report.append(f"Min processing time: {min_time:.2f}s") report.append("") # Category analysis categories = self.metadata.get('categories', {}) report.append("CATEGORY ANALYSIS") report.append("-" * 40) for category, test_ids in categories.items(): category_results = [r for r in results if r['test_id'] in test_ids] if category_results: passed = len([r for r in category_results if r['passed']]) total = len(category_results) pass_rate = (passed / total) * 100 report.append(f"{category}: {passed}/{total} ({pass_rate:.1f}%)") report.append("") report.append("=" * 80) return "\n".join(report) def save_results(self, results: List[Dict], summary: Dict): """Save test results to file""" timestamp = datetime.now().strftime("%Y%m%d_%H%M%S") # Save detailed results results_file = f"decomposer_test_results_{timestamp}.json" with open(results_file, 'w', encoding='utf-8') as f: json.dump({ "summary": summary, "results": results, "metadata": self.metadata }, f, ensure_ascii=False, indent=2) # Save report report_file = f"decomposer_test_report_{timestamp}.txt" report = self.generate_report(results, summary) with open(report_file, 'w', encoding='utf-8') as f: f.write(report) print(f"\nResults saved:") print(f" Detailed: {results_file}") print(f" Report: {report_file}") def main(): """Main function""" print("Decomposer Service Test Runner") print("=" * 50) # Initialize tester tester = DecomposerTester() # Load test cases if not tester.load_test_cases(): print("Failed to load test cases") return # Run tests results, summary = tester.run_all_tests() if not results: print("No tests executed") return # Generate and display report report = tester.generate_report(results, summary) print(report) # Save results tester.save_results(results, summary) if __name__ == "__main__": main() 